/*
 * Copyright (C) 2008-2022 Advanced Micro Devices, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Signature:
 * double amd_fasterf(double x);
 * Computes the error function of x
 *
 * Maximum ULP is 1.87988
 * This implementation is not IEEE 754 compliant and does not add NaN
 *
 *
 *
 * Implementation Notes
 * ----------------------
 *  if x > 5.921875
 *     return 1.0
 *
 *  if 1.0 < x <= 5.921875
 *      return 1 - exp(x * (-1.128379198989930192746772277672040367511127479667880683087214917312973705421 + x * (-0.6366193111195503928974474361758894666404675632145002162894331610917819652684 + x * (-0.10277547084408357532105868282211330916733358058054124524473286591478952967105 + x * (1.913904214189711886762071087079941066171685447503716970303298596385024529787e-2 + x * (1.825913620408778114794169081827109689163333138218777377173097737573780074451e-4 + x * (-1.647411432107627860506561538441809818128299435687100607632403662627229969442e-3 + x * (5.21818424825711363023814805627743102562544825002695874303608394240491926905e-4 + x * (4.91627168817438044269386766419565454318509950036800085804021703321697091835e-5 + x * (-1.302981172729131079630523589391656092208513771111088247857933578594392780292e-4 + x * (7.615199404557680638356591201054196713693837373671412154758563642454062526076e-5 + x * (-2.96935339283727595127063299180979185095022523878782406229763314957081808351e-5 + x * (8.878165181834831585186432336594595410842906530722031490846761209704716619195e-6 + x * (-2.12714951505431619504049300115915574833256638114737995020961934817058311951e-6 + x * (4.146746535162880252608396592166861942608845052332004241597308855885179990494e-7 + x * (-6.59030545681603281811648088253177498666005293866364687961783648988232273307e-8 + x * (8.482541531526446204466824249004710358281109743716038706482471097755571216e-9 + x * (-8.717025659536669540755909448858779028619932413055195403437445698307186886677e-10 + x * (6.986310311662613657315676676388719057504624524859113603391352651484705086844e-11 + x * (-4.207783872043116961017859246460942240015393112860254295006478500309621030333e-12 + x * (1.790995692530692947437965495563199880874085822185316938795832479020883353374e-13 + x * (-4.801396646154358189127560929835283812276105659218143392174762905750106085853e-15 + x * 6.09464019738248521658138120195945654655592494197989524075299306234484609923e-17)))))))))))))))))))))
 *
 *  if x <= 1.0
 *       return x * (1.1283791670955125656539546480394381212700000251759 + x^2 * (-0.37612638903183519538684678924796441989200004437331 + x^2 * (0.112837916709441847162115702407296623359855842865354 + x^2 * (-2.68661706431114670328213173933416573498428131606314e-2 + x^2 * (5.2239776061184733153931752295100839160294359393454e-3 + x^2 * (-8.548325929314490260657717454060788378873328143637e-4 + x^2 * (1.2055293576900624102905702190107107910178870863567e-4 + x^2 * (-1.4924712302009784215659095812852066398064014024546e-5 + x^2 * (1.6447131571277696087513420311315555247123856186925e-6 + x^2 * (-1.6206313758481267251097356025630327970797016185629e-7 + x^2 * (1.3710980397970515999986433969994634679368669925207e-8 + x^2 * (-7.7794684888425169575250383296580432148481928654068e-10))))))))))))
 *
 * if x is +/- zero, return zero
 * if x is +/- infinity, 1 is returned
 * if x is NaN, NaN is returned
 *
 */

#include <libm_util_amd.h>
#include <libm/alm_special.h>
#include <libm/amd_funcs_internal.h>
#include <libm_macros.h>
#include <libm/types.h>
#include <libm/typehelper.h>
#include <libm/compiler.h>
#include <libm/poly.h>

#define BOUND1 1.0
#define BOUND2 5.921875

double ALM_PROTO_FAST(erf)(double x) {

    /* Set the polynomial coefficients */
  
    uint64_t AH[]={0x3ff20dd750429b6d, 0xbfd812746b0379bd, 0x3fbce2f21a040d16, 0xbf9b82ce311fa93e,
		   0x3f7565bccf92b2f9, 0xbf4c02db03dd71d4, 0x3f1f9a2baa8fedd0, 0xbeef4ca4d6f3e2e1,
		   0x3ebb97fd3d9926d0, 0xbe85c0726f04cb5a, 0x3e4d71b0f1b08156, 0xbe0abae491c28860};
  
    uint64_t BH[]={0xbff20dd758d25ff4, 0xbfe45f2f7628562a, 0xbfba4f7e461b3921, 0x3f93992f604e0b05,
		   0x3f27eebfdb640bcc, 0xbf5afdbe8e55573b, 0x3f41195488d78110, 0x3f09c68216ea9240,
		   0xbf2114144e09abcc, 0x3f13f6794bb9cb84, 0xbeff22cc1d2f21fb, 0x3ee29e6dbb394a45,
		   0xbec1d804d01ae12d, 0x3e9bd40e69c39497, 0xbe71b0d2cbfee91a, 0x3e423753970b571e,
		   0xbe0df393acf45881, 0x3dd3342dc7d8ce27, 0xbd92818b20d1fbc6, 0x3d4934bdf577f269,
		   0xbcf59fa2297bf414, 0x3c91910cfbd5c781};

    uint64_t ux = asuint64(x);
    uint64_t sign =  ux & SIGNBIT_DP64;

    ux = ux & ~SIGNBIT_DP64;
    x = asdouble(ux);

    double result;

    if((ux <= asuint64(BOUND1))) {

        double x2 = x * x;
	double sH = asdouble(AH[11]);

	for (int i=10; i >= 0; i--) {
	  sH = sH*x2 + asdouble(AH[i]);
	}
	result = sH * x;
        result = asdouble(sign | asuint64(result));
    }
    else if((ux <= asuint64(BOUND2))) {

        double sH = asdouble(BH[21]);

	for (int i=20; i >= 0; i--) {
          sH = sH*x + asdouble(BH[i]);
	}
	double result1 = sH * x;
	result = 1.0 - exp(result1);
        result = asdouble(sign | asuint64(result));
    }
    else {
        result = 1.0;
        result = asdouble(sign | asuint64(result));
    }
    return result;
}

strong_alias (__erf_finite, ALM_PROTO_FAST(erf))
weak_alias (amd_erf, ALM_PROTO_FAST(erf))
weak_alias (erf, ALM_PROTO_FAST(erf))
